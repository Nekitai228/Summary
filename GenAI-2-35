from transformers import pipeline
import re
from typing import Tuple, Optional, Dict, List

# Глобальные константы для параметров
MODEL_NAME = "facebook/bart-large-cnn"
MAX_SUMMARY_LENGTH = 100
MIN_SUMMARY_LENGTH = 30
MIN_INPUT_WORDS = 10

# Глобальная переменная для модели (загружается один раз)
summarizer = None

def summarize(text: str) -> Tuple[str, int]:
    """
    Создаёт краткое содержание научного текста (максимум 100 слов)
    Возвращает пару из сжатого текста и количества его слов

    Args:
        text(str): Входной текст для суммаризации

    Returns:
        Tuple[str,int]: Кортеж из краткого содержания и количества слов

    Raises:
        ValueError: Если текст пустой, слишком короткий или содержит только пробелы
        RuntimeError: Если произошла ошибка при загрузке модели или суммаризации
        Exception: Для других непредвиденных ошибок
    """

    try:
        if not text or not isinstance(text, str):
            raise ValueError("Текст не может быть пустым или не строкового типа")
        
        # Очистка текста от лишних пробелов
        text_clean = re.sub(r'\s+', ' ', text).strip()
        if not text_clean:
            raise ValueError("Текст содержит только пробелы или пуст")
        
        if len(text_clean.split()) < MIN_INPUT_WORDS:
            raise ValueError(f"Текст слишком короткий для суммаризации (минимум {MIN_INPUT_WORDS} слов)")

        # Суммаризация
        try:
            result = summarizer(
                text_clean,
                max_length=MAX_SUMMARY_LENGTH,
                min_length=MIN_SUMMARY_LENGTH,
                do_sample=False,
                truncation=True
            )
        except Exception as summarization_error:
            raise RuntimeError(f"Ошибка во время суммаризации: {summarization_error}")

        # Получение и обрезка summary
        summary = result[0]['summary_text']
        words = summary.split()[:MAX_SUMMARY_LENGTH]
        final_summary = ' '.join(words)

        return final_summary, len(words)

    except (ValueError, RuntimeError):
        # Перевыбрасываем ожидаемые исключения
        raise
    except Exception as unexpected_error:
        # Обрабатываем непредвиденные ошибки
        raise Exception(f"Непредвиденная ошибка: {unexpected_error}")
    

def generate_annotation_with_keywords(text: str, keywords: List[str]) -> Dict:
    """
    Генерирует аннотацию с обязательным включением заданных ключевых слов
    
    Args:
        text (str): Исходный текст статьи
        keywords (List[str]): Список ключевых слов для включения
        
    Returns:
        Dict: Словарь с результатами генерации аннотации
    """
    try:
        # Суммаризируем исходный текст
        summary, word_count = summarize(text)
        
        # Проверяем наличие ключевых слов в аннотации
        missing_keywords = [kw for kw in keywords if kw.lower() not in summary.lower()]
        
        # Если каких-то ключевых слов нет, добавляем их
        if missing_keywords:
            # Создаем дополнение с недостающими ключевыми словами
            addition = f" The work pays special attention to {', '.join(missing_keywords)}."
            new_summary = summary + addition
            
            # Обновляем счетчик слов и обрезаем если превышен лимит
            words = new_summary.split()
            if len(words) > MAX_SUMMARY_LENGTH:
                new_summary = ' '.join(words[:MAX_SUMMARY_LENGTH])
            
            summary = new_summary
            word_count = len(summary.split())
        
        return {
            'annotation': summary,
            'word_count': word_count,
            'keywords_present': all(kw.lower() in summary.lower() for kw in keywords),
            'missing_keywords': missing_keywords,
            'all_keywords': keywords
        }
        
    except Exception as e:
        raise RuntimeError(f"Ошибка при генерации аннотации: {e}")

# Использование 
def main():
    """Основная функция для запуска скрипта"""
    global summarizer
    
    try:
        # Загружаем модель один раз при запуске
        try:
            if summarizer is None:
                summarizer = pipeline("summarization", model=MODEL_NAME)
        except Exception as model_error:
            raise RuntimeError(f"Ошибка загрузки модели: {model_error}")
            print(f"Модель {MODEL_NAME} успешно загружена")
            
        # Генерация аннотации с ключевыми словами
        prompt = input("Введите текст статьи: ")
            
        if not prompt.strip():
            print("Ошибка: Введен пустой текст")
            return
            
        keywords = ['Нейросети', 'Обучение', 'Данные']
        
        
            
        result = generate_annotation_with_keywords(prompt, keywords)
        
        print("\n" + "="*50)
        print("АННОТАЦИЯ:")
        print("="*50)
        print(result['annotation'])
        print(f"\nКоличество слов: {result['word_count']}")
        
        print("\nПРОВЕРКА КЛЮЧЕВЫХ СЛОВ:")
        for keyword in result['all_keywords']:
            status = "Yes" if keyword.lower() in result['annotation'].lower() else "No"
            print(f"{status} {keyword}")
        
        
    except ValueError as ve:
        print(f"Ошибка входных данных: {ve}")
    except RuntimeError as re:
        print(f"Ошибка обработки: {re}")
    except Exception as e:
        print(f"Неожиданная ошибка: {e}")
    except KeyboardInterrupt:
        print("\nПрограмма прервана пользователем")

if __name__ == "__main__":
    main()
